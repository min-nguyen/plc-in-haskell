%       dvips -ta4 exercise02 -o
%       ps2pdf -sPAPERSIZE=a4 exercise02.ps

\documentclass[a4paper]{article}
\usepackage{times,fullpage}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{bprd}
\usepackage[dvips]{graphicx}
\usepackage{xcolor}

\setcounter{exercise-sheet}{2}

\begin{document}

\begin{center}
{\Large\bf Exercises week \arabic{exercise-sheet}\\[1ex]
Monday 31 August 2009}\\[1ex]
% {\small 2009-08-28}\\[2ex]
\end{center}

\subsection*{Goal of the exercises}

The goal of this week's exercises is (1) to better understand Haskell
polymorphic types and functions, and the use of accumulating
parameters; and (2) to understand the compilation and evaluation of
simple arithmetic expressions with variables and let-bindings.\\


\noindent 
It is recommended that you hand in solutions to
Exercises~\ref{exer-tree-traversal}, \ref{exer-multi-let-eval},
\ref{exer-multi-let-closed}, \ref{exer-comp-expr-to-ints}, and
\ref{exer-simultaneous-let} after the exercise classes.  \\


\begin{exercise}\label{exer-right-linear} {\color{red}{This exercise isn't in the book, but I've translated the questions and the answers anyway.}}
  Define an Haskell function \texttt{linear ::\ Int -> Tree Int} so that
  \texttt{linear $n$} produces a right-linear tree with $n$ nodes.
  For instance, \texttt{linear 0} should produce \texttt{Lf}, and
  \texttt{linear 2} should produce \texttt{Br 2 Lf (Br 1 Lf Lf)}. The definition
  of \texttt{Tree} is given below.
{\codesetup\begin{verbatim}
   data Tree a = Br a (Tree a) (Tree a) | Lf
\end{verbatim}}

\end{exercise}


\begin{exercise}\label{exer-tree-traversal} {\color{red}{This exercise isn't in the book (nor is the function preorder1), but I've translated the questions and the answers anyway.}}
  Lecture 2 presents an Haskell function \texttt{preorder1 ::\ Tree a ->
    [a]} that returns a list of the node values in a tree, in
  \emph{preorder} (root before left subtree before right subtree).\\
  
  Now define a function \texttt{inorder} that returns the node values
  in \emph{inorder} (left subtree before root before right subtree)
  and a function \texttt{postorder} that returns the node values in
  \emph{postorder} (left subtree before right subtree before root):

{\codesetup\begin{verbatim}
   inorder   : Tree a -> [a]
   postorder : Tree a -> [a]
\end{verbatim}}

\noindent 
Thus if \texttt{t} is \texttt{Br 1 (Br 2 Lf Lf) (Br 3 Lf Lf)},
then \texttt{inorder t} is \texttt{[2, 1, 3]} and\\ \texttt{postorder t}
is \texttt{[2, 3, 1]}.

It should hold that \texttt{inorder (linear n)} is \texttt{[n, n-1,
  \ldots, 2, 1]} and \texttt{postorder (linear n)} is \texttt{[1, 2,
  \ldots, n-1, n]}, where \texttt{linear n} produces a right-linear
  tree as in Exercise~\ref{exer-right-linear}.
  
  Note that the postfix (or reverse Polish) representation of an
  expression is just a \emph{postorder list of the nodes in the
    expression's abstract syntax tree}.\\
  
  Finally, define a more efficient version of \texttt{inorder} that
  uses an auxiliary function \texttt{ino ::\ Tree a -> [a] -> [a]
    } with an accumulating parameter; and similarly for
  \texttt{postorder}.  
\end{exercise}


\begin{exercise}\label{exer-multi-let-eval}
  Extend the expression language \texttt{Expr} from \texttt{Intcomp1.hs}
  with multiple \emph{sequential} let-bindings, such as this (in
  concrete syntax):

{\codesetup\begin{verbatim}
   let x1 = 5+7   x2 = x1*2 in x1+x2 end
\end{verbatim}}


\noindent 
Next, revise the \texttt{eval} interpreter from \texttt{Intcomp1.hs} to work
for the \texttt{Expr} language extended with multiple sequential
let-bindings. To evaluate this, the right-hand side expression \texttt{5+7} must be
evaluated and bound to \texttt{x1}, and then \texttt{x1*2} must be
evaluated and bound to \texttt{x2}, after which the let-body
\texttt{x1+x2} is evaluated.
\end{exercise}


\begin{exercise}\label{exer-multi-let-closed}
  Revise the function \texttt{freevars ::\ Expr -> [String]} to work
  for the language as extended in Exercise~\ref{exer-multi-let-eval}.
  Note that the example expression in the beginning of
  Exercise~\ref{exer-multi-let-eval} has no free variables, but
  \texttt{let x1 = x1+7 in x1+8 end} has the free variable
  \texttt{x1}, because the variable \texttt{x1} is bound only in the
  body (\texttt{x1+8}), not in the right-hand side (\texttt{x1+7}), of
  its own binding.  (There \emph{are} programming languages where a
  variable can be used in the right-hand side of its own binding, but
  this is not such a language.)
\end{exercise}


\begin{exercise}\label{exer-multi-let-tcomp}
  Revise the \texttt{Expr}-to-\texttt{TExpr} compiler \texttt{tcomp ::\ 
    Expr -> TExpr} from \texttt{Intcomp1.fs} to work for the extended
  \texttt{Expr} language.
  There is no need to modify the \texttt{TExpr} language or the
  \texttt{teval} interpreter to accommodate multiple sequential
  let-bindings.
\end{exercise}


\begin{exercise}\label{exer-comp-expr-to-ints}
  {\color{red}{This exercise uses the file Machine.java, but I've managed to translate the question such that the file isn't needed.}}  Write a bytecode assembler (in Haskell) that translates a list
  of bytecode instructions for the simple stack machine in
  \texttt{Intcomp1.fs} into a list of integers.  The integers should be
  the corresponding bytecodes as seen below.
  {\codesetup\begin{verbatim}
  SCST = 0, SVAR = 1, SADD = 2, SSUB = 3, SMUL = 4, SPOP = 5, SSWAP = 6;\end{verbatim}}
  \noindent 
  Thus you should write a function
  \texttt{assemble ::\ [SInstr] -> [Int]}.\\
  
  Use this function together with \texttt{scomp} from
  \texttt{Intcomp1.hs} to make a compiler from the original expressions
  language \texttt{Expr} to a list of bytecodes \texttt{[Int]}.
  
  You may test the output of your compiler by typing in the numbers as
  an \texttt{Int} array in the \texttt{Machine.java} interpreter.  (Or
  you may solve Exercise~\ref{exer-read-ints-into-stack-machine} below
  to avoid this manual work).
\end{exercise}


\begin{exercise}\label{exer-read-ints-into-stack-machine}
  Modify the compiler from Exercise~\ref{exer-comp-expr-to-ints} to
  write the lists of integers to a file.  A list \texttt{inss} of
  integers may be output to the file called \texttt{fname} using this
  function (found in \texttt{Intcomp1.hs}):

{\codesetup\begin{verbatim}
   intsToFile :: [Int] -> String -> IO ()
   intsToFile inss fname 
    = do let text = intercalate " " (map show inss)
         writeFile fname text
\end{verbatim}}

\noindent
{\color{red}{This second part of the exercise requires the student to modify the file Machine.java, so I haven't translated this question.}} Then modify the stack machine interpreter in \texttt{Machine.java} to
read the sequence of integers from a text file, and execute it as a
stack machine program.  The name of the textfile may be given as a
command-line parameter to the Java program.  Reading from the text
file may be done using the StringTokenizer class or StreamTokenizer
class; see e.g. \emph{Java Precisely} Example~145.
  
It is essential that the compiler (in F\#) and the interpreter (in
Java) agree on the intermediate language: what integer represents what
instruction.
\end{exercise}


\begin{exercise}\label{exer-simultaneous-let}
  
  Now modify the interpretation of the language from
  Exercise~\ref{exer-multi-let-eval} so that multiple let-bindings are
  \emph{simultaneous} rather than sequential.  For instance,

{\codesetup\begin{verbatim}
   let x1 = 5+7   x2 = x1*2 in x1+x2 end
\end{verbatim}}

\noindent
should still have the abstract syntax 

{\codesetup\begin{verbatim}
   Let [("x1", ...); ("x2", ...)] (Prim "+" (Var "x1") (Var "x2"))
\end{verbatim}}

\noindent 
but now the interpretation is that all right-hand sides must be
evaluated before any left-hand side variable gets bound to its
right-hand side value.  That is, in the above expression, the
occurrence of \texttt{x1} in the right-hand side of \texttt{x2} has
nothing to do with the \texttt{x1} of the first binding; it is a free
variable.

Revise the \texttt{eval} interpreter to work for this version of the
\texttt{Expr} language.  The idea is that all the right-hand side
expressions should be evaluated, after which all the variables are
bound to those values simultaneously.  Hence

{\codesetup\begin{verbatim}
   let x = 11 in let x = 22  y = x+1 in x+y end end 
\end{verbatim}}

\noindent 
should compute \texttt{12 + 22} because \texttt{x} in \texttt{x+1} is
the outer \texttt{x} (and hence is 11), and \texttt{x} in \texttt{x+y}
is the inner \texttt{x} (and hence is 22).  In other words, in the
let-binding

{\codesetup\begin{verbatim}
   let x1 = e1  ...  xn = en in e end
\end{verbatim}}

\noindent 
the scope of the variables \texttt{x1 \ldots\ xn} should be
\texttt{e}, not \texttt{e1 \ldots\ en}.  
\end{exercise}


\begin{exercise} 
Define a version of the (naive) Fibonacci function 

{\codesetup\begin{verbatim}
   fib :: Int -> Int
   fib n = if n < 2 
           then n 
           else fib (n-1) + fib (n-2)
\end{verbatim}}

\noindent 
in Postscript\@.  Compute Fibonacci of $0, 1, \ldots, 25$.  
\end{exercise}

\begin{exercise}
  Write a Postscript program to compute the sum $1+2+\cdots+1000$.  It
  must really do the summation, not use the closed-form expression
  $\frac{n(n+1)}{2}$ with $n=1000$.  (Trickier: do this using only a
  \texttt{for}-loop, no function definition).
\end{exercise}

\end{document}

